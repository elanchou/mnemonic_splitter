import { MnemonicPhrase, Share } from '../types';

/**
 * Validates if the input string contains exactly 12 words.
 */
export const validateInput = (input: string): { valid: boolean; words: string[]; error?: string } => {
  const cleanInput = input.trim().replace(/\s+/g, ' ');
  if (!cleanInput) {
    return { valid: false, words: [], error: 'Please enter a mnemonic phrase.' };
  }
  
  const words = cleanInput.split(' ');
  if (words.length !== 12) {
    return { valid: false, words, error: `Expected 12 words, found ${words.length}.` };
  }

  // Basic check for alphabetical characters only
  const invalidWord = words.find(w => !/^[a-zA-Z]+$/.test(w));
  if (invalidWord) {
    return { valid: false, words, error: `Invalid word detected: "${invalidWord}". Only letters are allowed.` };
  }

  return { valid: true, words: words.map(w => w.toLowerCase()) };
};

/**
 * Splits a 12-word secret into 3 shares of 8 words each using an overlapping scheme.
 * Share 1: Words 1-8
 * Share 2: Words 5-12
 * Share 3: Words 9-12 + 1-4
 */
export const splitSecret = (words: MnemonicPhrase): Share[] => {
  if (words.length !== 12) throw new Error("Input must be 12 words");

  const blockA = words.slice(0, 4);   // 1-4
  const blockB = words.slice(4, 8);   // 5-8
  const blockC = words.slice(8, 12);  // 9-12

  return [
    { id: 1, label: "Share 1", words: [...blockA, ...blockB] },
    { id: 2, label: "Share 2", words: [...blockB, ...blockC] },
    { id: 3, label: "Share 3", words: [...blockC, ...blockA] },
  ];
};

/**
 * Attempts to reconstruct the 12-word secret from any 2 shares.
 * It looks for a 4-word overlapping sequence between the tail of one share and head of another.
 */
export const recoverSecret = (shareAStr: string, shareBStr: string): { success: boolean; words: string[]; error?: string } => {
  const cleanA = shareAStr.trim().replace(/\s+/g, ' ').toLowerCase().split(' ');
  const cleanB = shareBStr.trim().replace(/\s+/g, ' ').toLowerCase().split(' ');

  if (cleanA.length !== 8 || cleanB.length !== 8) {
    return { success: false, words: [], error: "Each share must contain exactly 8 words." };
  }

  const checkOverlap = (first: string[], second: string[]): string[] | null => {
    // We expect an overlap of exactly 4 words for this specific scheme
    const overlapSize = 4;
    
    // Check if tail of 'first' matches head of 'second'
    const tail = first.slice(first.length - overlapSize);
    const head = second.slice(0, overlapSize);
    
    const isMatch = tail.every((val, index) => val === head[index]);
    
    if (isMatch) {
      // Combine: First + (Second without the head)
      return [...first, ...second.slice(overlapSize)];
    }
    return null;
  };

  // Try A -> B
  let result = checkOverlap(cleanA, cleanB);
  if (result) return { success: true, words: result };

  // Try B -> A
  result = checkOverlap(cleanB, cleanA);
  if (result) return { success: true, words: result };

  return { success: false, words: [], error: "No valid overlap found. Ensure you are using two different shares generated by this tool." };
};

/**
 * Rotates an array to the left by 4 positions.
 * Used if the reconstruction results in a shifted sequence (e.g., Block C, Block A, Block B).
 */
export const rotateWords = (words: string[]): string[] => {
  const rotationAmount = 4;
  const part1 = words.slice(rotationAmount);
  const part2 = words.slice(0, rotationAmount);
  return [...part1, ...part2];
};
